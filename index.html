<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>æ¤ç‰©è¯†åˆ«æ¼”ç¤º - TFJS æ¨¡å‹</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸŒ¿ æ¤ç‰©è¯†åˆ«å®éªŒå¹³å°</h1>
      <div class="subtitle">æ¬¢ä»”å°ç»„</div>
    </header>



    <div class="main-content">
      <div class="card">
        <div class="card-title">ä¸Šä¼ æ¤ç‰©å›¾ç‰‡</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              ğŸ“ é€‰æ‹©å›¾ç‰‡æ–‡ä»¶
              <input type="file" id="fileInput" accept="image/*" />
            </label>
          </div>
          <button class="predict-btn" id="predictBtn" disabled>ğŸ” å¼€å§‹è¯†åˆ«</button>
          <div class="small">æ”¯æŒ JPGã€PNG æ ¼å¼ï¼Œæœ€å¤§ 10MB</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">è¯†åˆ«ç»“æœé¢„è§ˆ</div>
        <div class="preview-section">
          <div class="img-wrap" id="imgWrap">
            <div class="placeholder-text">è¯·ä¸Šä¼ æ¤ç‰©å›¾ç‰‡è¿›è¡Œè¯†åˆ«</div>
            <img id="preview" alt="å›¾ç‰‡é¢„è§ˆ" style="display: none;" />
          </div>
          <div class="results" id="results"></div>
        </div>
      </div>
    </div>

    <div class="card status-card">
      <div class="status" id="status">
        <span class="loading"></span> æ­£åœ¨åŠ è½½æ¨¡å‹â€¦
      </div>
      <div class="model-info">æ¨¡å‹è·¯å¾„ï¼š<span class="kbd" id="modelPath"></span></div>
    </div>
  </div>

  <script>
    const STATUS = document.getElementById('status');
    const MODEL_PATH_EL = document.getElementById('modelPath');
    const FILE_INPUT = document.getElementById('fileInput');
    const PREVIEW = document.getElementById('preview');
    const PREDICT_BTN = document.getElementById('predictBtn');
    const RESULTS = document.getElementById('results');
    const IMG_WRAP = document.getElementById('imgWrap');
    const PLACEHOLDER_TEXT = IMG_WRAP.querySelector('.placeholder-text');

    // å¤„ç†åŒ…å«ç©ºæ ¼çš„ç›®å½•å
    const rawModelPath = './plant model1/model.json';
    const modelPath = encodeURI(rawModelPath);
    MODEL_PATH_EL.textContent = rawModelPath;

    let model = null;
    let inputSize = 224; // å…œåº•é»˜è®¤
    let labels = null;   // è‹¥åç»­æä¾› ./plant model1/labels.json å¯è‡ªåŠ¨åŠ è½½

    // ä» model.json ä¸­å°è¯•è§£æç±»åˆ«åç§°ï¼ˆå¤šç§å¸¸è§å­—æ®µï¼‰
    async function tryLoadLabelsFromModelJson() {
      try {
        const res = await fetch(modelPath);
        if (!res.ok) return false;
        const j = await res.json();
        const candidates = [
          j?.userDefinedMetadata?.outputLabels,
          j?.userDefinedMetadata?.labels,
          j?.userDefinedMetadata?.classes,
          j?.metadata?.labels,
          j?.class_names,
          j?.modelTopology?.training_config?.class_names,
          j?.signature?.labels
        ];
        for (const c of candidates) {
          if (Array.isArray(c) && c.length && typeof c[0] === 'string') {
            labels = c;
            return true;
          }
        }
        // æœ‰äº›å¯¼å‡ºä¼šæŠŠ labels æ”¾åœ¨ userDefinedMetadata ä¸‹çš„ä»»æ„é”®
        const udm = j?.userDefinedMetadata;
        if (udm && typeof udm === 'object') {
          for (const k of Object.keys(udm)) {
            const v = udm[k];
            if (Array.isArray(v) && v.length && typeof v[0] === 'string') {
              labels = v;
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }

    async function tryLoadLabels() {
      // ä¼˜å…ˆä» model.json è§£æ
      const ok = await tryLoadLabelsFromModelJson();
      if (ok) return;
      // å›é€€åˆ°ç‹¬ç«‹ labels.json
      try {
        const labelsPath = encodeURI('./plant model1/labels.json');
        const res = await fetch(labelsPath);
        if (res.ok) {
          labels = await res.json();
        }
      } catch (e) {
        // æ—  labels.json æ—¶å¿½ç•¥
      }
    }

    async function loadModel() {
      try {
        // ç»å¤§å¤šæ•° model.json + model.weights.bin æ˜¯ tfjs-layers
        model = await tf.loadLayersModel(modelPath);
        STATUS.innerHTML = '<span style="color: #48bb78;">âœ… æ¨¡å‹åŠ è½½æˆåŠŸ</span>';
        // è‡ªåŠ¨è¯»å–è¾“å…¥å°ºå¯¸
        const shape = model.inputs?.[0]?.shape || null;
        if (shape && shape.length >= 3) {
          // å½¢å¦‚ [null, H, W, C]
          const h = shape[1] || inputSize;
          const w = shape[2] || inputSize;
          // è‹¥ä¸ä¸€è‡´å–è¾ƒå°è€…ä»¥ä¿æŒæ–¹å½¢
          inputSize = Math.min(h || inputSize, w || inputSize) || inputSize;
          STATUS.innerHTML += `<br><span class="small">è¾“å…¥å°ºå¯¸ï¼š${inputSize}x${inputSize}</span>`;
        }
        await tryLoadLabels();
        if (labels) {
          STATUS.innerHTML += `<br><span class="small">è¯†åˆ«ç±»åˆ«ï¼š${labels.length} ç§æ¤ç‰©</span>`;
        }
        PREDICT_BTN.disabled = false;
      } catch (err) {
        console.warn('å°è¯•ä»¥ tfjs-layers åŠ è½½å¤±è´¥ï¼Œæ”¹ç”¨ GraphModelâ€¦', err);
        try {
          model = await tf.loadGraphModel(modelPath);
          STATUS.innerHTML = '<span style="color: #48bb78;">âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼ˆGraphModelï¼‰</span>';
          // GraphModel æ— æ³•ç›´æ¥ä» inputs.shape è¯»å–ï¼Œæ²¿ç”¨é»˜è®¤ 224
          await tryLoadLabels();
          if (labels) {
            STATUS.innerHTML += `<br><span class="small">è¯†åˆ«ç±»åˆ«ï¼š${labels.length} ç§æ¤ç‰©</span>`;
          }
          PREDICT_BTN.disabled = false;
        } catch (err2) {
          console.error(err2);
          STATUS.innerHTML = '<span style="color: #e53e3e;">âŒ æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ model.json è·¯å¾„ä¸ç±»å‹</span>';
        }
      }
    }

    function showResults(probArray, topK = 5) {
      const indexed = probArray.map((p, i) => ({ i, p }));
      indexed.sort((a, b) => b.p - a.p);
      const tops = indexed.slice(0, topK);

      RESULTS.innerHTML = '';
      
      if (tops.length === 0) {
        RESULTS.innerHTML = '<div class="small">æœªè¯†åˆ«åˆ°æœ‰æ•ˆç»“æœ</div>';
        return;
      }

      tops.forEach(({ i, p }, index) => {
        const name = labels && labels[i] ? labels[i] : `æ¤ç‰©ç±»åˆ« #${i + 1}`;
        const percentage = (p * 100).toFixed(2);
        const confidence = p > 0.8 ? 'é«˜' : p > 0.5 ? 'ä¸­' : 'ä½';
        
        const div = document.createElement('div');
        div.className = 'result-item';
        div.innerHTML = `
          <div>
            <strong>${index === 0 ? 'ğŸ† ' : ''}${name}</strong>
            <div class="small">ç½®ä¿¡åº¦ï¼š${confidence}</div>
          </div>
          <div class="result-percentage">${percentage}%</div>
        `;
        RESULTS.appendChild(div);
      });
    }

    function preprocess(imgEl) {
      return tf.tidy(() => {
        let t = tf.browser.fromPixels(imgEl);
        // ç»Ÿä¸€æ–¹å½¢å°ºå¯¸
        t = tf.image.resizeBilinear(t, [inputSize, inputSize], true);
        // [0,1] å½’ä¸€åŒ–
        t = t.toFloat().div(255);
        // å¢ç»´ï¼š [1, H, W, C]
        t = t.expandDims(0);
        return t;
      });
    }

    async function predict() {
      if (!model || !PREVIEW.src) return;
      
      // ä¿å­˜æŒ‰é’®åŸå§‹çŠ¶æ€
      const originalText = PREDICT_BTN.innerHTML;
      PREDICT_BTN.disabled = true;
      PREDICT_BTN.innerHTML = 'â³ è¯†åˆ«ä¸­...';
      
      RESULTS.innerHTML = '<div class="small" style="text-align: center; padding: 20px;">ğŸ” æ­£åœ¨åˆ†ææ¤ç‰©ç‰¹å¾...</div>';
      
      try {
        const input = preprocess(PREVIEW);
        let output = null;
        
        try {
          output = model.predict ? model.predict(input) : model.execute(input);
        } catch (e) {
          // GraphModel å¯èƒ½éœ€è¦æ˜ç¡®è¾“å‡ºèŠ‚ç‚¹ï¼Œå›é€€ try/catch
          try {
            output = model.execute(input);
          } catch (e2) {
            throw new Error('æ— æ³•æ‰§è¡Œæ¨¡å‹é¢„æµ‹');
          }
        }

        // å…¼å®¹æ•°ç»„è¾“å‡º
        const outTensor = Array.isArray(output) ? output[0] : output;
        const probs = await outTensor.data();
        showResults(Array.from(probs));
        tf.dispose([input, output]);
        
      } catch (e) {
        console.error(e);
        RESULTS.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e53e3e;">
            <div>âŒ è¯†åˆ«å¤±è´¥</div>
            <div class="small">${e.message || 'æœªçŸ¥é”™è¯¯'}</div>
          </div>
        `;
      } finally {
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        PREDICT_BTN.disabled = false;
        PREDICT_BTN.innerHTML = originalText;
      }
    }

    function handleFileSelect(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼ˆJPGã€PNGç­‰æ ¼å¼ï¼‰');
        return;
      }
      
      if (file.size > 10 * 1024 * 1024) {
        alert('å›¾ç‰‡æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB');
        return;
      }
      
      const url = URL.createObjectURL(file);
      PREVIEW.onload = () => {
        URL.revokeObjectURL(url);
        RESULTS.innerHTML = '';
        PLACEHOLDER_TEXT.style.display = 'none';
        PREVIEW.style.display = 'block';
      };
      PREVIEW.src = url;
    }

    FILE_INPUT.addEventListener('change', () => {
      const file = FILE_INPUT.files?.[0];
      handleFileSelect(file);
    });

    // æ‹–æ”¾åŠŸèƒ½
    IMG_WRAP.addEventListener('dragover', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.add('drag-over');
    });

    IMG_WRAP.addEventListener('dragleave', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
    });

    IMG_WRAP.addEventListener('drop', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      handleFileSelect(file);
    });

    // ç‚¹å‡»é¢„è§ˆåŒºåŸŸä¹Ÿå¯ä»¥é€‰æ‹©æ–‡ä»¶
    IMG_WRAP.addEventListener('click', () => {
      FILE_INPUT.click();
    });

    PREDICT_BTN.addEventListener('click', predict);

    // åˆå§‹åŒ–
    loadModel();
  </script>
</body>
</html>