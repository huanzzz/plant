<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>æ¤ç‰©è¯†åˆ«æ¼”ç¤º - TFJS æ¨¡å‹</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸŒ¿ æ¤ç‰©è¯†åˆ«å®éªŒå¹³å°</h1>
      <div class="subtitle">æ¬¢ä»”å°ç»„</div>
    </header>

    <div class="main-content">
      <div class="card">
        <div class="card-title">ğŸ“¦ ä¸Šä¼ æ¨¡å‹æ–‡ä»¶</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              ğŸ“‚ é€‰æ‹©æ¨¡å‹å‹ç¼©åŒ…
              <input type="file" id="modelInput" accept=".zip" />
            </label>
          </div>
          <div class="small">æ”¯æŒ ZIP æ ¼å¼ï¼Œéœ€åŒ…å« model.json å’Œ model.weights.bin</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">ä¸Šä¼ æ¤ç‰©å›¾ç‰‡</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              ğŸ“ é€‰æ‹©å›¾ç‰‡æ–‡ä»¶
              <input type="file" id="fileInput" accept="image/*" />
            </label>
          </div>
          <button class="predict-btn" id="predictBtn" disabled>ğŸ” å¼€å§‹è¯†åˆ«</button>
          <div class="small">æ”¯æŒ JPGã€PNG æ ¼å¼ï¼Œæœ€å¤§ 10MB</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">è¯†åˆ«ç»“æœé¢„è§ˆ</div>
        <div class="preview-section">
          <div class="img-wrap" id="imgWrap">
            <div class="placeholder-text">è¯·ä¸Šä¼ æ¤ç‰©å›¾ç‰‡è¿›è¡Œè¯†åˆ«</div>
            <img id="preview" alt="å›¾ç‰‡é¢„è§ˆ" style="display: none;" />
          </div>
          <div class="results" id="results"></div>
        </div>
      </div>
    </div>

    <div class="card status-card">
      <div class="status" id="status">
        <span class="loading"></span> æ­£åœ¨åŠ è½½æ¨¡å‹â€¦
      </div>
      <div class="model-info">æ¨¡å‹è·¯å¾„ï¼š<span class="kbd" id="modelPath"></span></div>
    </div>

    <div class="card">
      <div class="card-title">ğŸ› ï¸ è°ƒè¯•å·¥å…·</div>
      <div style="padding: 12px; background: #f7fafc; border-radius: 8px;">
        <div style="margin-bottom: 12px;">
          <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #4a5568;">é¢„å¤„ç†æ¨¡å¼ï¼š</label>
          <select id="preprocessSelect" style="width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; background: white; font-size: 14px;">
            <option value="simple">æ¨¡å¼1: ç®€å•å½’ä¸€åŒ– [0,1]</option>
            <option value="imagenet">æ¨¡å¼2: ImageNetæ ‡å‡†åŒ–</option>
            <option value="mobilenet_v2">æ¨¡å¼3: MobileNetV2æ ‡å‡†åŒ– (æ¨è)</option>
            <option value="range_neg1_1">æ¨¡å¼4: å½’ä¸€åŒ–åˆ° [-1,1]</option>
            <option value="none">æ¨¡å¼5: æ— æ ‡å‡†åŒ– [0,255]</option>
            <option value="caffe">æ¨¡å¼6: Caffeé£æ ¼ (BGR)</option>
          </select>
        </div>
        <div style="font-size: 12px; color: #718096; line-height: 1.5;">
          ğŸ’¡ æç¤ºï¼šå¦‚æœé¢„æµ‹ç»“æœä¸å‡†ç¡®ï¼Œè¯·å°è¯•åˆ‡æ¢é¢„å¤„ç†æ¨¡å¼ã€‚å¤§å¤šæ•°TensorFlow.jsæ¨¡å‹ä½¿ç”¨ç®€å•å½’ä¸€åŒ–ã€‚
        </div>
        <div style="margin-top: 12px;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="debugToggle" checked style="margin-right: 8px;">
            <span style="font-size: 14px; color: #4a5568;">å¯ç”¨æ§åˆ¶å°è°ƒè¯•ä¿¡æ¯</span>
          </label>
        </div>
        <div style="margin-top: 12px;">
          <button id="testAllBtn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
            ğŸ§ª è‡ªåŠ¨æµ‹è¯•æ‰€æœ‰æ¨¡å¼
          </button>
          <div style="font-size: 11px; color: #718096; margin-top: 6px; text-align: center;">
            ç‚¹å‡»åå°†ä¾æ¬¡æµ‹è¯•æ‰€æœ‰6ç§é¢„å¤„ç†æ¨¡å¼
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const STATUS = document.getElementById('status');
    const MODEL_PATH_EL = document.getElementById('modelPath');
    const MODEL_INPUT = document.getElementById('modelInput');
    const FILE_INPUT = document.getElementById('fileInput');
    const PREVIEW = document.getElementById('preview');
    const PREDICT_BTN = document.getElementById('predictBtn');
    const RESULTS = document.getElementById('results');
    const IMG_WRAP = document.getElementById('imgWrap');
    const PLACEHOLDER_TEXT = IMG_WRAP.querySelector('.placeholder-text');

    let model = null;
    let inputSize = 224; // å…œåº•é»˜è®¤
    let labels = null;   // ä»æ¨¡å‹æ–‡ä»¶ä¸­åŠ è½½
    let modelType = null; // è®°å½•æ¨¡å‹ç±»å‹
    let modelFiles = null; // å­˜å‚¨ä¸Šä¼ çš„æ¨¡å‹æ–‡ä»¶
    
    // MobileNet æ ‡å‡†é¢„å¤„ç†å‚æ•°
    const IMAGENET_MEAN = [0.485, 0.456, 0.406];
    const IMAGENET_STD = [0.229, 0.224, 0.225];
    
    // è°ƒè¯•æ¨¡å¼ï¼ˆä½¿ç”¨å…¨å±€å˜é‡ä»¥ä¾¿åŠ¨æ€åˆ‡æ¢ï¼‰
    window.DEBUG_MODE = true;
    
    // ä¾¿æ·è®¿é—®å‡½æ•°
    function isDebugMode() {
      return window.DEBUG_MODE === true;
    }

    // ä» model.json ä¸­å°è¯•è§£æç±»åˆ«åç§°ï¼ˆå¤šç§å¸¸è§å­—æ®µï¼‰
    async function tryLoadLabelsFromModelJson(modelJsonData) {
      try {
        const j = modelJsonData;
        const candidates = [
          j?.userDefinedMetadata?.outputLabels,
          j?.userDefinedMetadata?.labels,
          j?.userDefinedMetadata?.classes,
          j?.metadata?.labels,
          j?.class_names,
          j?.modelTopology?.training_config?.class_names,
          j?.signature?.labels
        ];
        for (const c of candidates) {
          if (Array.isArray(c) && c.length && typeof c[0] === 'string') {
            labels = c;
            return true;
          }
        }
        // æœ‰äº›å¯¼å‡ºä¼šæŠŠ labels æ”¾åœ¨ userDefinedMetadata ä¸‹çš„ä»»æ„é”®
        const udm = j?.userDefinedMetadata;
        if (udm && typeof udm === 'object') {
          for (const k of Object.keys(udm)) {
            const v = udm[k];
            if (Array.isArray(v) && v.length && typeof v[0] === 'string') {
              labels = v;
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }

    async function tryLoadLabels(modelJsonData) {
      // ä¼˜å…ˆä» model.json è§£æ
      const ok = await tryLoadLabelsFromModelJson(modelJsonData);
      if (ok) return;
      // å¯ä»¥åœ¨zipä¸­åŒ…å«labels.jsonæ–‡ä»¶ä½œä¸ºå¤‡é€‰
      if (modelFiles && modelFiles['labels.json']) {
        try {
          const labelsText = await modelFiles['labels.json'].async('text');
          labels = JSON.parse(labelsText);
        } catch (e) {
          // æ—  labels.json æ—¶å¿½ç•¥
        }
      }
    }

    async function loadModel() {
      if (!modelFiles) {
        STATUS.innerHTML = '<span style="color: #f59e0b;">âš ï¸ è¯·å…ˆä¸Šä¼ æ¨¡å‹æ–‡ä»¶</span>';
        return;
      }

      try {
        STATUS.innerHTML = '<span class="loading"></span> æ­£åœ¨åŠ è½½æ¨¡å‹â€¦';
        
        // ä»ä¸Šä¼ çš„æ–‡ä»¶åˆ›å»º IOHandler
        const modelJsonText = await modelFiles['model.json'].async('text');
        const modelJsonData = JSON.parse(modelJsonText);
        const weightsBlob = await modelFiles['model.weights.bin'].async('blob');
        const weightData = await weightsBlob.arrayBuffer();
        
        // æå– weight specs
        let weightSpecs = [];
        if (modelJsonData.weightsManifest && modelJsonData.weightsManifest.length > 0) {
          weightSpecs = modelJsonData.weightsManifest[0].weights || [];
        }
        
        // åˆ›å»ºè‡ªå®šä¹‰ IOHandler
        const customIOHandler = {
          load: async () => {
            return {
              modelTopology: modelJsonData.modelTopology,
              format: modelJsonData.format,
              generatedBy: modelJsonData.generatedBy,
              convertedBy: modelJsonData.convertedBy,
              weightSpecs: weightSpecs,
              weightData: weightData,
              userDefinedMetadata: modelJsonData.userDefinedMetadata
            };
          }
        };
        
        // å°è¯•ä½œä¸º LayersModel åŠ è½½
        try {
          model = await tf.loadLayersModel(customIOHandler);
          modelType = 'layers';
          STATUS.innerHTML = '<span style="color: #48bb78;">âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼ˆLayersModelï¼‰</span>';
          
          // è‡ªåŠ¨è¯»å–è¾“å…¥å°ºå¯¸
          const shape = model.inputs?.[0]?.shape || null;
          if (shape && shape.length >= 3) {
            // å½¢å¦‚ [null, H, W, C]
            const h = shape[1] || inputSize;
            const w = shape[2] || inputSize;
            // è‹¥ä¸ä¸€è‡´å–è¾ƒå°è€…ä»¥ä¿æŒæ–¹å½¢
            inputSize = Math.min(h || inputSize, w || inputSize) || inputSize;
            STATUS.innerHTML += `<br><span class="small">è¾“å…¥å°ºå¯¸ï¼š${inputSize}x${inputSize}</span>`;
          }
          
          // è¾“å‡ºæ¨¡å‹ä¿¡æ¯ç”¨äºè°ƒè¯•
          if (isDebugMode()) {
            console.log('æ¨¡å‹ç±»å‹:', modelType);
            console.log('è¾“å…¥å½¢çŠ¶:', shape);
            console.log('è¾“å‡ºå½¢çŠ¶:', model.outputs?.[0]?.shape);
            console.log('æ¨¡å‹æ‘˜è¦:');
            model.summary();
          }
        } catch (err) {
          console.warn('å°è¯•ä»¥ tfjs-layers åŠ è½½å¤±è´¥ï¼Œæ”¹ç”¨ GraphModelâ€¦', err);
          model = await tf.loadGraphModel(customIOHandler);
          modelType = 'graph';
          STATUS.innerHTML = '<span style="color: #48bb78;">âœ… æ¨¡å‹åŠ è½½æˆåŠŸï¼ˆGraphModelï¼‰</span>';
          // GraphModel æ— æ³•ç›´æ¥ä» inputs.shape è¯»å–ï¼Œæ²¿ç”¨é»˜è®¤ 224
          STATUS.innerHTML += `<br><span class="small">è¾“å…¥å°ºå¯¸ï¼š${inputSize}x${inputSize}</span>`;
        }
        
        await tryLoadLabels(modelJsonData);
        if (labels) {
          STATUS.innerHTML += `<br><span class="small">è¯†åˆ«ç±»åˆ«ï¼š${labels.length} ç§æ¤ç‰©</span>`;
          if (isDebugMode()) {
            console.log('æ ‡ç­¾åˆ—è¡¨:', labels);
          }
        }
        
        MODEL_PATH_EL.textContent = 'ç”¨æˆ·ä¸Šä¼ çš„æ¨¡å‹';
        PREDICT_BTN.disabled = false;
        
      } catch (err) {
        console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', err);
        STATUS.innerHTML = '<span style="color: #e53e3e;">âŒ æ¨¡å‹åŠ è½½å¤±è´¥ï¼š' + err.message + '</span>';
        MODEL_PATH_EL.textContent = 'åŠ è½½å¤±è´¥';
      }
    }

    function showResults(probArray, topK = 5) {
      const indexed = probArray.map((p, i) => ({ i, p }));
      indexed.sort((a, b) => b.p - a.p);
      const tops = indexed.slice(0, topK);

      RESULTS.innerHTML = '';
      
      if (tops.length === 0) {
        RESULTS.innerHTML = '<div class="small">æœªè¯†åˆ«åˆ°æœ‰æ•ˆç»“æœ</div>';
        return;
      }

      tops.forEach(({ i, p }, index) => {
        const name = labels && labels[i] ? labels[i] : `æ¤ç‰©ç±»åˆ« #${i + 1}`;
        const percentage = (p * 100).toFixed(2);
        const confidence = p > 0.8 ? 'é«˜' : p > 0.5 ? 'ä¸­' : 'ä½';
        
        const div = document.createElement('div');
        div.className = 'result-item';
        div.innerHTML = `
          <div>
            <strong>${index === 0 ? 'ğŸ† ' : ''}${name}</strong>
            <div class="small">ç½®ä¿¡åº¦ï¼š${confidence}</div>
          </div>
          <div class="result-percentage">${percentage}%</div>
        `;
        RESULTS.appendChild(div);
      });
    }

    // é¢„å¤„ç†æ¨¡å¼é…ç½®
    let preprocessMode = 'mobilenet_v2'; // é»˜è®¤ä½¿ç”¨ MobileNetV2 æ ‡å‡†é¢„å¤„ç†
    
    function preprocess(imgEl) {
      return tf.tidy(() => {
        let t = tf.browser.fromPixels(imgEl);
        
        if (isDebugMode()) {
          console.log('=== å›¾åƒé¢„å¤„ç†å¼€å§‹ ===');
          console.log('åŸå§‹å›¾åƒå½¢çŠ¶:', t.shape);
          console.log('åŸå§‹å›¾åƒå€¼èŒƒå›´:', [tf.min(t).dataSync()[0], tf.max(t).dataSync()[0]]);
        }
        
        // ç»Ÿä¸€æ–¹å½¢å°ºå¯¸
        t = tf.image.resizeBilinear(t, [inputSize, inputSize], true);
        
        // è½¬ä¸ºæµ®ç‚¹æ•°
        t = t.toFloat();
        
        // æ ¹æ®æ¨¡å¼é€‰æ‹©é¢„å¤„ç†æ–¹å¼
        if (preprocessMode === 'simple') {
          // æ¨¡å¼1: ç®€å•å½’ä¸€åŒ–åˆ° [0,1]
          t = t.div(255);
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: ç®€å•å½’ä¸€åŒ– [0,1]');
          }
        } else if (preprocessMode === 'imagenet') {
          // æ¨¡å¼2: ImageNet æ ‡å‡†é¢„å¤„ç†
          // å½’ä¸€åŒ–åˆ° [0,1] ç„¶åæ ‡å‡†åŒ–
          t = t.div(255);
          const mean = tf.tensor1d(IMAGENET_MEAN);
          const std = tf.tensor1d(IMAGENET_STD);
          t = t.sub(mean).div(std);
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: ImageNetæ ‡å‡†åŒ– (mean=[0.485,0.456,0.406], std=[0.229,0.224,0.225])');
          }
        } else if (preprocessMode === 'mobilenet_v2') {
          // æ¨¡å¼3: MobileNetV2 / TensorFlow æ ‡å‡†é¢„å¤„ç†
          // å½’ä¸€åŒ–åˆ° [-1, 1]
          t = t.div(127.5).sub(1.0);
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: MobileNetV2æ ‡å‡†åŒ– [(x/127.5)-1] â†’ [-1,1]');
          }
        } else if (preprocessMode === 'range_neg1_1') {
          // æ¨¡å¼4: å¦ä¸€ç§å½’ä¸€åŒ–åˆ° [-1,1] çš„æ–¹å¼
          t = t.sub(127.5).div(127.5);
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: å½’ä¸€åŒ–åˆ° [-1,1] [(x-127.5)/127.5]');
          }
        } else if (preprocessMode === 'none') {
          // æ¨¡å¼5: ä¸åšå½’ä¸€åŒ–ï¼Œä¿æŒ [0,255]
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: æ— æ ‡å‡†åŒ– [0,255]');
          }
        } else if (preprocessMode === 'caffe') {
          // æ¨¡å¼6: Caffe é£æ ¼ - BGR é¡ºåº + å‡å‡å€¼
          // è½¬æ¢ RGB -> BGR
          const [r, g, b] = tf.split(t, 3, 2);
          t = tf.concat([b, g, r], 2);
          // å‡å» ImageNet å‡å€¼ (BGR é¡ºåº)
          const mean = tf.tensor1d([103.939, 116.779, 123.68]);
          t = t.sub(mean);
          if (isDebugMode()) {
            console.log('é¢„å¤„ç†æ¨¡å¼: Caffeé£æ ¼ (BGR + å‡å‡å€¼)');
          }
        }
        
        if (isDebugMode()) {
          console.log('é¢„å¤„ç†åå½¢çŠ¶:', t.shape);
          const minVal = tf.min(t).dataSync()[0];
          const maxVal = tf.max(t).dataSync()[0];
          const meanVal = tf.mean(t).dataSync()[0];
          console.log('é¢„å¤„ç†åç»Ÿè®¡: min=' + minVal.toFixed(4) + ', max=' + maxVal.toFixed(4) + ', mean=' + meanVal.toFixed(4));
          console.log('=== å›¾åƒé¢„å¤„ç†å®Œæˆ ===');
        }
        
        // å¢ç»´ï¼š [1, H, W, C]
        t = t.expandDims(0);
        
        return t;
      });
    }

    async function predict() {
      if (!model || !PREVIEW.src) return;
      
      // ä¿å­˜æŒ‰é’®åŸå§‹çŠ¶æ€
      const originalText = PREDICT_BTN.innerHTML;
      PREDICT_BTN.disabled = true;
      PREDICT_BTN.innerHTML = 'â³ è¯†åˆ«ä¸­...';
      
      RESULTS.innerHTML = '<div class="small" style="text-align: center; padding: 20px;">ğŸ” æ­£åœ¨åˆ†ææ¤ç‰©ç‰¹å¾...</div>';
      
      try {
        if (isDebugMode()) {
          console.log('=== å¼€å§‹é¢„æµ‹ ===');
          console.log('æ¨¡å‹ç±»å‹:', modelType);
        }
        
        const input = preprocess(PREVIEW);
        
        if (isDebugMode()) {
          console.log('è¾“å…¥å¼ é‡å½¢çŠ¶:', input.shape);
          console.log('è¾“å…¥å¼ é‡å€¼èŒƒå›´:', [tf.min(input).dataSync()[0], tf.max(input).dataSync()[0]]);
        }
        
        let output = null;
        
        // æ ¹æ®æ¨¡å‹ç±»å‹ä½¿ç”¨ä¸åŒçš„é¢„æµ‹æ–¹æ³•
        if (modelType === 'layers') {
          output = model.predict(input);
        } else if (modelType === 'graph') {
          output = model.execute(input);
        } else {
          // å…¼å®¹æ¨¡å¼
          try {
            output = model.predict ? model.predict(input) : model.execute(input);
          } catch (e) {
            try {
              output = model.execute(input);
            } catch (e2) {
              throw new Error('æ— æ³•æ‰§è¡Œæ¨¡å‹é¢„æµ‹');
            }
          }
        }

        // å…¼å®¹æ•°ç»„è¾“å‡º
        const outTensor = Array.isArray(output) ? output[0] : output;
        
        if (isDebugMode()) {
          console.log('è¾“å‡ºå¼ é‡å½¢çŠ¶:', outTensor.shape);
          console.log('è¾“å‡ºå¼ é‡å€¼èŒƒå›´:', [tf.min(outTensor).dataSync()[0], tf.max(outTensor).dataSync()[0]]);
        }
        
        const probs = await outTensor.data();
        const probsArray = Array.from(probs);
        
        if (isDebugMode()) {
          console.log('é¢„æµ‹æ¦‚ç‡:', probsArray);
          console.log('æ¦‚ç‡æ€»å’Œ:', probsArray.reduce((a, b) => a + b, 0));
          probsArray.forEach((p, i) => {
            const label = labels && labels[i] ? labels[i] : `ç±»åˆ« ${i}`;
            console.log(`  ${label}: ${(p * 100).toFixed(2)}%`);
          });
          console.log('=== é¢„æµ‹å®Œæˆ ===');
        }
        
        showResults(probsArray);
        tf.dispose([input, output]);
        
      } catch (e) {
        console.error('é¢„æµ‹é”™è¯¯:', e);
        RESULTS.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e53e3e;">
            <div>âŒ è¯†åˆ«å¤±è´¥</div>
            <div class="small">${e.message || 'æœªçŸ¥é”™è¯¯'}</div>
          </div>
        `;
      } finally {
        // æ¢å¤æŒ‰é’®çŠ¶æ€
        PREDICT_BTN.disabled = false;
        PREDICT_BTN.innerHTML = originalText;
      }
    }

    function handleFileSelect(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼ˆJPGã€PNGç­‰æ ¼å¼ï¼‰');
        return;
      }
      
      if (file.size > 10 * 1024 * 1024) {
        alert('å›¾ç‰‡æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB');
        return;
      }
      
      const url = URL.createObjectURL(file);
      PREVIEW.onload = () => {
        URL.revokeObjectURL(url);
        RESULTS.innerHTML = '';
        PLACEHOLDER_TEXT.style.display = 'none';
        PREVIEW.style.display = 'block';
      };
      PREVIEW.src = url;
    }

    // å¤„ç†æ¨¡å‹æ–‡ä»¶ä¸Šä¼ 
    MODEL_INPUT.addEventListener('change', async () => {
      const file = MODEL_INPUT.files?.[0];
      if (!file) return;
      
      if (!file.name.endsWith('.zip')) {
        alert('âš ï¸ è¯·é€‰æ‹© ZIP æ ¼å¼çš„æ¨¡å‹å‹ç¼©åŒ…');
        return;
      }
      
      try {
        STATUS.innerHTML = '<span class="loading"></span> æ­£åœ¨è§£å‹æ¨¡å‹æ–‡ä»¶â€¦';
        MODEL_PATH_EL.textContent = 'è§£å‹ä¸­...';
        
        const zip = await JSZip.loadAsync(file);
        
        // æŸ¥æ‰¾ model.json å’Œ model.weights.bin
        let modelJson = null;
        let weightsFile = null;
        
        // éå†zipæ–‡ä»¶ï¼Œå¯»æ‰¾model.jsonå’Œweightsæ–‡ä»¶
        for (const [filename, fileObj] of Object.entries(zip.files)) {
          if (fileObj.dir) continue;
          
          const baseName = filename.split('/').pop();
          if (baseName === 'model.json') {
            modelJson = fileObj;
          } else if (baseName === 'model.weights.bin' || baseName.endsWith('.weights.bin')) {
            weightsFile = fileObj;
          }
        }
        
        if (!modelJson || !weightsFile) {
          throw new Error('å‹ç¼©åŒ…ä¸­ç¼ºå°‘å¿…éœ€æ–‡ä»¶ï¼ˆmodel.json æˆ– model.weights.binï¼‰');
        }
        
        modelFiles = {
          'model.json': modelJson,
          'model.weights.bin': weightsFile
        };
        
        // æ£€æŸ¥æ˜¯å¦æœ‰labels.json
        for (const [filename, fileObj] of Object.entries(zip.files)) {
          if (fileObj.dir) continue;
          const baseName = filename.split('/').pop();
          if (baseName === 'labels.json') {
            modelFiles['labels.json'] = fileObj;
            break;
          }
        }
        
        console.log('âœ… æ¨¡å‹æ–‡ä»¶è§£å‹æˆåŠŸ');
        console.log('- model.json:', modelJson.name);
        console.log('- weights:', weightsFile.name);
        if (modelFiles['labels.json']) {
          console.log('- labels.json:', modelFiles['labels.json'].name);
        }
        
        // è‡ªåŠ¨åŠ è½½æ¨¡å‹
        await loadModel();
        
      } catch (err) {
        console.error('æ¨¡å‹ä¸Šä¼ å¤±è´¥:', err);
        STATUS.innerHTML = '<span style="color: #e53e3e;">âŒ ' + err.message + '</span>';
        MODEL_PATH_EL.textContent = 'åŠ è½½å¤±è´¥';
        alert('âŒ æ¨¡å‹ä¸Šä¼ å¤±è´¥ï¼š' + err.message);
      }
    });

    FILE_INPUT.addEventListener('change', () => {
      const file = FILE_INPUT.files?.[0];
      handleFileSelect(file);
    });

    // æ‹–æ”¾åŠŸèƒ½
    IMG_WRAP.addEventListener('dragover', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.add('drag-over');
    });

    IMG_WRAP.addEventListener('dragleave', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
    });

    IMG_WRAP.addEventListener('drop', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      handleFileSelect(file);
    });

    // ç‚¹å‡»é¢„è§ˆåŒºåŸŸä¹Ÿå¯ä»¥é€‰æ‹©æ–‡ä»¶
    IMG_WRAP.addEventListener('click', () => {
      FILE_INPUT.click();
    });

    PREDICT_BTN.addEventListener('click', predict);

    // è‡ªåŠ¨æµ‹è¯•æ‰€æœ‰æ¨¡å¼
    const TEST_ALL_BTN = document.getElementById('testAllBtn');
    TEST_ALL_BTN.addEventListener('click', async () => {
      if (!model || !PREVIEW.src) {
        alert('âš ï¸ è¯·å…ˆä¸Šä¼ å›¾ç‰‡ï¼');
        return;
      }
      
      const modes = ['mobilenet_v2', 'range_neg1_1', 'simple', 'imagenet', 'caffe', 'none'];
      const modeNames = {
        'mobilenet_v2': 'æ¨¡å¼3: MobileNetV2 [-1,1]',
        'range_neg1_1': 'æ¨¡å¼4: å¦ä¸€ç§ [-1,1]',
        'simple': 'æ¨¡å¼1: ç®€å• [0,1]',
        'imagenet': 'æ¨¡å¼2: ImageNetæ ‡å‡†åŒ–',
        'caffe': 'æ¨¡å¼6: Caffeé£æ ¼',
        'none': 'æ¨¡å¼5: æ— æ ‡å‡†åŒ– [0,255]'
      };
      
      TEST_ALL_BTN.disabled = true;
      TEST_ALL_BTN.innerHTML = 'â³ æµ‹è¯•ä¸­...';
      
      console.log('\n' + '='.repeat(70));
      console.log('ğŸ§ª å¼€å§‹è‡ªåŠ¨æµ‹è¯•æ‰€æœ‰é¢„å¤„ç†æ¨¡å¼');
      console.log('='.repeat(70));
      console.log('ğŸ“¸ å½“å‰å›¾ç‰‡å·²åŠ è½½ï¼Œå°†ä¾æ¬¡æµ‹è¯• 6 ç§é¢„å¤„ç†æ¨¡å¼\n');
      
      const results = [];
      
      for (let i = 0; i < modes.length; i++) {
        const mode = modes[i];
        preprocessMode = mode;
        PREPROCESS_SELECT.value = mode;
        
        console.log(`\n[${ i + 1}/6] æµ‹è¯• ${modeNames[mode]}`);
        console.log('-'.repeat(70));
        
        try {
          const input = preprocess(PREVIEW);
          let output = null;
          
          if (modelType === 'layers') {
            output = model.predict(input);
          } else if (modelType === 'graph') {
            output = model.execute(input);
          } else {
            output = model.predict ? model.predict(input) : model.execute(input);
          }
          
          const outTensor = Array.isArray(output) ? output[0] : output;
          const probs = await outTensor.data();
          const probsArray = Array.from(probs);
          
          // æ‰¾å‡ºæœ€é«˜æ¦‚ç‡çš„ç±»åˆ«
          let maxProb = -1;
          let maxIdx = -1;
          probsArray.forEach((p, idx) => {
            if (p > maxProb) {
              maxProb = p;
              maxIdx = idx;
            }
          });
          
          const predictedLabel = labels && labels[maxIdx] ? labels[maxIdx] : `ç±»åˆ« ${maxIdx}`;
          
          results.push({
            mode: modeNames[mode],
            label: predictedLabel,
            confidence: maxProb,
            probs: probsArray
          });
          
          console.log(`âœ… é¢„æµ‹ç»“æœ: ${predictedLabel} (${(maxProb * 100).toFixed(2)}%)`);
          console.log('å®Œæ•´æ¦‚ç‡åˆ†å¸ƒ:');
          probsArray.forEach((p, idx) => {
            const label = labels && labels[idx] ? labels[idx] : `ç±»åˆ« ${idx}`;
            console.log(`  ${label}: ${(p * 100).toFixed(2)}%`);
          });
          
          tf.dispose([input, output]);
          
          // çŸ­æš‚å»¶è¿Ÿä»¥ä¾¿æŸ¥çœ‹
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (e) {
          console.error(`âŒ ${modeNames[mode]} æµ‹è¯•å¤±è´¥:`, e.message);
          results.push({
            mode: modeNames[mode],
            label: 'é”™è¯¯',
            confidence: 0,
            error: e.message
          });
        }
      }
      
      // è¾“å‡ºæ±‡æ€»
      console.log('\n' + '='.repeat(70));
      console.log('ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»');
      console.log('='.repeat(70));
      
      const summary = {};
      results.forEach(r => {
        if (!r.error) {
          if (!summary[r.label]) {
            summary[r.label] = [];
          }
          summary[r.label].push({mode: r.mode, conf: r.confidence});
        }
      });
      
      console.log('\næŒ‰é¢„æµ‹ç±»åˆ«åˆ†ç»„:');
      Object.keys(summary).forEach(label => {
        console.log(`\nğŸ·ï¸  ${label}:`);
        summary[label].forEach(item => {
          console.log(`   ${item.mode}: ${(item.conf * 100).toFixed(2)}%`);
        });
      });
      
      console.log('\n' + '='.repeat(70));
      console.log('ğŸ’¡ ä½¿ç”¨å»ºè®®:');
      console.log('   1. æŸ¥çœ‹å“ªä¸ªæ¨¡å¼é¢„æµ‹å‡ºäº†æ­£ç¡®çš„ç±»åˆ«ï¼ˆå°è‰ï¼‰');
      console.log('   2. é€‰æ‹©è¯¥æ¨¡å¼ä½œä¸ºé»˜è®¤é¢„å¤„ç†æ–¹å¼');
      console.log('   3. ç”¨å¤šå¼ è®­ç»ƒå›¾ç‰‡éªŒè¯è¯¥æ¨¡å¼çš„å‡†ç¡®æ€§');
      console.log('='.repeat(70) + '\n');
      
      TEST_ALL_BTN.disabled = false;
      TEST_ALL_BTN.innerHTML = 'ğŸ§ª è‡ªåŠ¨æµ‹è¯•æ‰€æœ‰æ¨¡å¼';
      
      alert('âœ… æµ‹è¯•å®Œæˆï¼è¯·æŸ¥çœ‹æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†ç»“æœã€‚');
    });

    // é¢„å¤„ç†æ¨¡å¼åˆ‡æ¢
    const PREPROCESS_SELECT = document.getElementById('preprocessSelect');
    PREPROCESS_SELECT.addEventListener('change', (e) => {
      preprocessMode = e.target.value;
      console.log('\n' + '='.repeat(50));
      console.log('ğŸ”„ é¢„å¤„ç†æ¨¡å¼å·²åˆ‡æ¢ä¸º:', preprocessMode);
      
      const modeDescriptions = {
        'simple': 'ç®€å•å½’ä¸€åŒ– x/255 â†’ [0,1]',
        'imagenet': 'ImageNetæ ‡å‡†åŒ– (x/255 - mean)/std',
        'mobilenet_v2': 'MobileNetV2æ ‡å‡†åŒ– x/127.5 - 1 â†’ [-1,1] â­æ¨è',
        'range_neg1_1': 'å¦ä¸€ç§[-1,1]æ–¹å¼ (x-127.5)/127.5',
        'none': 'æ— æ ‡å‡†åŒ–ï¼Œä¿æŒ [0,255]',
        'caffe': 'Caffeé£æ ¼ BGR + å‡å‡å€¼'
      };
      
      console.log('ğŸ“ è¯´æ˜:', modeDescriptions[preprocessMode] || 'æœªçŸ¥æ¨¡å¼');
      console.log('ğŸ’¡ æç¤º: ä¸Šä¼ å›¾ç‰‡åç‚¹å‡»"å¼€å§‹è¯†åˆ«"æµ‹è¯•æ­¤æ¨¡å¼');
      console.log('='.repeat(50) + '\n');
      
      // å¦‚æœå·²ç»æœ‰å›¾ç‰‡ï¼Œæç¤ºå¯ä»¥é‡æ–°é¢„æµ‹
      if (PREVIEW.src && model) {
        console.log('â„¹ï¸  æ£€æµ‹åˆ°å·²ä¸Šä¼ å›¾ç‰‡ï¼Œå¯ä»¥ç›´æ¥ç‚¹å‡»"å¼€å§‹è¯†åˆ«"æŒ‰é’®æµ‹è¯•æ–°æ¨¡å¼');
      }
    });

    // è°ƒè¯•å¼€å…³
    const DEBUG_TOGGLE = document.getElementById('debugToggle');
    DEBUG_TOGGLE.addEventListener('change', (e) => {
      window.DEBUG_MODE = e.target.checked;
      console.log('è°ƒè¯•æ¨¡å¼:', window.DEBUG_MODE ? 'å¼€å¯' : 'å…³é—­');
    });
    
    // åˆå§‹åŒ–é¢„å¤„ç†æ¨¡å¼
    preprocessMode = 'mobilenet_v2'; // è®¾ç½®é»˜è®¤å€¼ä¸º MobileNetV2
    PREPROCESS_SELECT.value = 'mobilenet_v2'; // åŒæ­¥ä¸‹æ‹‰æ¡†
    
    console.log('\n' + '='.repeat(60));
    console.log('ğŸŒ¿ æ¤ç‰©è¯†åˆ«ç³»ç»Ÿå·²å¯åŠ¨');
    console.log('='.repeat(60));
    console.log('ğŸ“Œ é»˜è®¤é¢„å¤„ç†æ¨¡å¼: MobileNetV2æ ‡å‡†åŒ– [-1,1]');
    console.log('ğŸ“Œ è¿™æ˜¯TensorFlowé¢„è®­ç»ƒMobileNetæ¨¡å‹çš„æ ‡å‡†é¢„å¤„ç†æ–¹å¼');
    console.log('');
    console.log('ğŸ“¦ ä½¿ç”¨æ­¥éª¤:');
    console.log('  1ï¸âƒ£  ä¸Šä¼ æ¨¡å‹å‹ç¼©åŒ…ï¼ˆåŒ…å« model.json å’Œ model.weights.binï¼‰');
    console.log('  2ï¸âƒ£  ç­‰å¾…æ¨¡å‹åŠ è½½å®Œæˆ');
    console.log('  3ï¸âƒ£  ä¸Šä¼ æ¤ç‰©å›¾ç‰‡è¿›è¡Œè¯†åˆ«');
    console.log('');
    console.log('ğŸ”§ å¦‚æœè®­ç»ƒé›†å›¾ç‰‡é¢„æµ‹é”™è¯¯ï¼Œè¯·å°è¯•ä»¥ä¸‹æ­¥éª¤:');
    console.log('  1ï¸âƒ£  ä¸Šä¼ å°è‰çš„è®­ç»ƒå›¾ç‰‡');
    console.log('  2ï¸âƒ£  æŸ¥çœ‹æ§åˆ¶å°çš„é¢„æµ‹ç»“æœ');
    console.log('  3ï¸âƒ£  å¦‚æœé”™è¯¯ï¼Œåˆ‡æ¢é¢„å¤„ç†æ¨¡å¼å¹¶é‡æ–°è¯†åˆ«');
    console.log('  4ï¸âƒ£  æµ‹è¯•æ‰€æœ‰6ç§æ¨¡å¼ï¼Œæ‰¾å‡ºæ­£ç¡®ç»“æœçš„æ¨¡å¼');
    console.log('');
    console.log('ğŸ’¡ å»ºè®®æµ‹è¯•é¡ºåº:');
    console.log('   æ¨¡å¼3 (MobileNetV2) â†’ æ¨¡å¼4 ([-1,1]) â†’ æ¨¡å¼1 ([0,1])');
    console.log('   â†’ æ¨¡å¼2 (ImageNet) â†’ æ¨¡å¼6 (Caffe) â†’ æ¨¡å¼5 ([0,255])');
    console.log('='.repeat(60) + '\n');

    // åˆå§‹åŒ–çŠ¶æ€
    STATUS.innerHTML = '<span style="color: #f59e0b;">âš ï¸ è¯·ä¸Šä¼ æ¨¡å‹æ–‡ä»¶</span>';
    MODEL_PATH_EL.textContent = 'æœªä¸Šä¼ ';
  </script>
</body>
</html>