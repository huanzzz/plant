<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>植物识别演示 - TFJS 模型</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>🌿 植物识别实验平台</h1>
      <div class="subtitle">欢仔小组</div>
    </header>



    <div class="main-content">
      <div class="card">
        <div class="card-title">上传植物图片</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              📁 选择图片文件
              <input type="file" id="fileInput" accept="image/*" />
            </label>
          </div>
          <button class="predict-btn" id="predictBtn" disabled>🔍 开始识别</button>
          <div class="small">支持 JPG、PNG 格式，最大 10MB</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">识别结果预览</div>
        <div class="preview-section">
          <div class="img-wrap" id="imgWrap">
            <div class="placeholder-text">请上传植物图片进行识别</div>
            <img id="preview" alt="图片预览" style="display: none;" />
          </div>
          <div class="results" id="results"></div>
        </div>
      </div>
    </div>

    <div class="card status-card">
      <div class="status" id="status">
        <span class="loading"></span> 正在加载模型…
      </div>
      <div class="model-info">模型路径：<span class="kbd" id="modelPath"></span></div>
    </div>
  </div>

  <script>
    const STATUS = document.getElementById('status');
    const MODEL_PATH_EL = document.getElementById('modelPath');
    const FILE_INPUT = document.getElementById('fileInput');
    const PREVIEW = document.getElementById('preview');
    const PREDICT_BTN = document.getElementById('predictBtn');
    const RESULTS = document.getElementById('results');
    const IMG_WRAP = document.getElementById('imgWrap');
    const PLACEHOLDER_TEXT = IMG_WRAP.querySelector('.placeholder-text');

    // 处理包含空格的目录名
    const rawModelPath = './plant model1/model.json';
    const modelPath = encodeURI(rawModelPath);
    MODEL_PATH_EL.textContent = rawModelPath;

    let model = null;
    let inputSize = 224; // 兜底默认
    let labels = null;   // 若后续提供 ./plant model1/labels.json 可自动加载

    // 从 model.json 中尝试解析类别名称（多种常见字段）
    async function tryLoadLabelsFromModelJson() {
      try {
        const res = await fetch(modelPath);
        if (!res.ok) return false;
        const j = await res.json();
        const candidates = [
          j?.userDefinedMetadata?.outputLabels,
          j?.userDefinedMetadata?.labels,
          j?.userDefinedMetadata?.classes,
          j?.metadata?.labels,
          j?.class_names,
          j?.modelTopology?.training_config?.class_names,
          j?.signature?.labels
        ];
        for (const c of candidates) {
          if (Array.isArray(c) && c.length && typeof c[0] === 'string') {
            labels = c;
            return true;
          }
        }
        // 有些导出会把 labels 放在 userDefinedMetadata 下的任意键
        const udm = j?.userDefinedMetadata;
        if (udm && typeof udm === 'object') {
          for (const k of Object.keys(udm)) {
            const v = udm[k];
            if (Array.isArray(v) && v.length && typeof v[0] === 'string') {
              labels = v;
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }

    async function tryLoadLabels() {
      // 优先从 model.json 解析
      const ok = await tryLoadLabelsFromModelJson();
      if (ok) return;
      // 回退到独立 labels.json
      try {
        const labelsPath = encodeURI('./plant model1/labels.json');
        const res = await fetch(labelsPath);
        if (res.ok) {
          labels = await res.json();
        }
      } catch (e) {
        // 无 labels.json 时忽略
      }
    }

    async function loadModel() {
      try {
        // 绝大多数 model.json + model.weights.bin 是 tfjs-layers
        model = await tf.loadLayersModel(modelPath);
        STATUS.innerHTML = '<span style="color: #48bb78;">✅ 模型加载成功</span>';
        // 自动读取输入尺寸
        const shape = model.inputs?.[0]?.shape || null;
        if (shape && shape.length >= 3) {
          // 形如 [null, H, W, C]
          const h = shape[1] || inputSize;
          const w = shape[2] || inputSize;
          // 若不一致取较小者以保持方形
          inputSize = Math.min(h || inputSize, w || inputSize) || inputSize;
          STATUS.innerHTML += `<br><span class="small">输入尺寸：${inputSize}x${inputSize}</span>`;
        }
        await tryLoadLabels();
        if (labels) {
          STATUS.innerHTML += `<br><span class="small">识别类别：${labels.length} 种植物</span>`;
        }
        PREDICT_BTN.disabled = false;
      } catch (err) {
        console.warn('尝试以 tfjs-layers 加载失败，改用 GraphModel…', err);
        try {
          model = await tf.loadGraphModel(modelPath);
          STATUS.innerHTML = '<span style="color: #48bb78;">✅ 模型加载成功（GraphModel）</span>';
          // GraphModel 无法直接从 inputs.shape 读取，沿用默认 224
          await tryLoadLabels();
          if (labels) {
            STATUS.innerHTML += `<br><span class="small">识别类别：${labels.length} 种植物</span>`;
          }
          PREDICT_BTN.disabled = false;
        } catch (err2) {
          console.error(err2);
          STATUS.innerHTML = '<span style="color: #e53e3e;">❌ 模型加载失败，请检查 model.json 路径与类型</span>';
        }
      }
    }

    function showResults(probArray, topK = 5) {
      const indexed = probArray.map((p, i) => ({ i, p }));
      indexed.sort((a, b) => b.p - a.p);
      const tops = indexed.slice(0, topK);

      RESULTS.innerHTML = '';
      
      if (tops.length === 0) {
        RESULTS.innerHTML = '<div class="small">未识别到有效结果</div>';
        return;
      }

      tops.forEach(({ i, p }, index) => {
        const name = labels && labels[i] ? labels[i] : `植物类别 #${i + 1}`;
        const percentage = (p * 100).toFixed(2);
        const confidence = p > 0.8 ? '高' : p > 0.5 ? '中' : '低';
        
        const div = document.createElement('div');
        div.className = 'result-item';
        div.innerHTML = `
          <div>
            <strong>${index === 0 ? '🏆 ' : ''}${name}</strong>
            <div class="small">置信度：${confidence}</div>
          </div>
          <div class="result-percentage">${percentage}%</div>
        `;
        RESULTS.appendChild(div);
      });
    }

    function preprocess(imgEl) {
      return tf.tidy(() => {
        let t = tf.browser.fromPixels(imgEl);
        // 统一方形尺寸
        t = tf.image.resizeBilinear(t, [inputSize, inputSize], true);
        // [0,1] 归一化
        t = t.toFloat().div(255);
        // 增维： [1, H, W, C]
        t = t.expandDims(0);
        return t;
      });
    }

    async function predict() {
      if (!model || !PREVIEW.src) return;
      
      // 保存按钮原始状态
      const originalText = PREDICT_BTN.innerHTML;
      PREDICT_BTN.disabled = true;
      PREDICT_BTN.innerHTML = '⏳ 识别中...';
      
      RESULTS.innerHTML = '<div class="small" style="text-align: center; padding: 20px;">🔍 正在分析植物特征...</div>';
      
      try {
        const input = preprocess(PREVIEW);
        let output = null;
        
        try {
          output = model.predict ? model.predict(input) : model.execute(input);
        } catch (e) {
          // GraphModel 可能需要明确输出节点，回退 try/catch
          try {
            output = model.execute(input);
          } catch (e2) {
            throw new Error('无法执行模型预测');
          }
        }

        // 兼容数组输出
        const outTensor = Array.isArray(output) ? output[0] : output;
        const probs = await outTensor.data();
        showResults(Array.from(probs));
        tf.dispose([input, output]);
        
      } catch (e) {
        console.error(e);
        RESULTS.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e53e3e;">
            <div>❌ 识别失败</div>
            <div class="small">${e.message || '未知错误'}</div>
          </div>
        `;
      } finally {
        // 恢复按钮状态
        PREDICT_BTN.disabled = false;
        PREDICT_BTN.innerHTML = originalText;
      }
    }

    function handleFileSelect(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('请选择有效的图片文件（JPG、PNG等格式）');
        return;
      }
      
      if (file.size > 10 * 1024 * 1024) {
        alert('图片文件大小不能超过10MB');
        return;
      }
      
      const url = URL.createObjectURL(file);
      PREVIEW.onload = () => {
        URL.revokeObjectURL(url);
        RESULTS.innerHTML = '';
        PLACEHOLDER_TEXT.style.display = 'none';
        PREVIEW.style.display = 'block';
      };
      PREVIEW.src = url;
    }

    FILE_INPUT.addEventListener('change', () => {
      const file = FILE_INPUT.files?.[0];
      handleFileSelect(file);
    });

    // 拖放功能
    IMG_WRAP.addEventListener('dragover', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.add('drag-over');
    });

    IMG_WRAP.addEventListener('dragleave', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
    });

    IMG_WRAP.addEventListener('drop', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      handleFileSelect(file);
    });

    // 点击预览区域也可以选择文件
    IMG_WRAP.addEventListener('click', () => {
      FILE_INPUT.click();
    });

    PREDICT_BTN.addEventListener('click', predict);

    // 初始化
    loadModel();
  </script>
</body>
</html>