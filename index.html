<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>植物识别演示 - TFJS 模型</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <header>
      <h1>🌿 植物识别实验平台</h1>
      <div class="subtitle">欢仔小组</div>
    </header>

    <div class="main-content">
      <div class="card">
        <div class="card-title">📦 上传模型文件</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              📂 选择模型压缩包
              <input type="file" id="modelInput" accept=".zip" />
            </label>
          </div>
          <div class="small">支持 ZIP 格式，需包含 model.json 和 model.weights.bin</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">上传植物图片</div>
        <div class="upload-section">
          <div class="file-input-wrapper">
            <label class="file-input-label">
              📁 选择图片文件
              <input type="file" id="fileInput" accept="image/*" />
            </label>
          </div>
          <button class="predict-btn" id="predictBtn" disabled>🔍 开始识别</button>
          <div class="small">支持 JPG、PNG 格式，最大 10MB</div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">识别结果预览</div>
        <div class="preview-section">
          <div class="img-wrap" id="imgWrap">
            <div class="placeholder-text">请上传植物图片进行识别</div>
            <img id="preview" alt="图片预览" style="display: none;" />
          </div>
          <div class="results" id="results"></div>
        </div>
      </div>
    </div>

    <div class="card status-card">
      <div class="status" id="status">
        <span class="loading"></span> 正在加载模型…
      </div>
      <div class="model-info">模型路径：<span class="kbd" id="modelPath"></span></div>
    </div>

    <div class="card">
      <div class="card-title">🛠️ 调试工具</div>
      <div style="padding: 12px; background: #f7fafc; border-radius: 8px;">
        <div style="margin-bottom: 12px;">
          <label style="display: block; margin-bottom: 4px; font-weight: 500; color: #4a5568;">预处理模式：</label>
          <select id="preprocessSelect" style="width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; background: white; font-size: 14px;">
            <option value="simple">模式1: 简单归一化 [0,1]</option>
            <option value="imagenet">模式2: ImageNet标准化</option>
            <option value="mobilenet_v2">模式3: MobileNetV2标准化 (推荐)</option>
            <option value="range_neg1_1">模式4: 归一化到 [-1,1]</option>
            <option value="none">模式5: 无标准化 [0,255]</option>
            <option value="caffe">模式6: Caffe风格 (BGR)</option>
          </select>
        </div>
        <div style="font-size: 12px; color: #718096; line-height: 1.5;">
          💡 提示：如果预测结果不准确，请尝试切换预处理模式。大多数TensorFlow.js模型使用简单归一化。
        </div>
        <div style="margin-top: 12px;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="debugToggle" checked style="margin-right: 8px;">
            <span style="font-size: 14px; color: #4a5568;">启用控制台调试信息</span>
          </label>
        </div>
        <div style="margin-top: 12px;">
          <button id="testAllBtn" style="width: 100%; padding: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
            🧪 自动测试所有模式
          </button>
          <div style="font-size: 11px; color: #718096; margin-top: 6px; text-align: center;">
            点击后将依次测试所有6种预处理模式
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const STATUS = document.getElementById('status');
    const MODEL_PATH_EL = document.getElementById('modelPath');
    const MODEL_INPUT = document.getElementById('modelInput');
    const FILE_INPUT = document.getElementById('fileInput');
    const PREVIEW = document.getElementById('preview');
    const PREDICT_BTN = document.getElementById('predictBtn');
    const RESULTS = document.getElementById('results');
    const IMG_WRAP = document.getElementById('imgWrap');
    const PLACEHOLDER_TEXT = IMG_WRAP.querySelector('.placeholder-text');

    let model = null;
    let inputSize = 224; // 兜底默认
    let labels = null;   // 从模型文件中加载
    let modelType = null; // 记录模型类型
    let modelFiles = null; // 存储上传的模型文件
    
    // MobileNet 标准预处理参数
    const IMAGENET_MEAN = [0.485, 0.456, 0.406];
    const IMAGENET_STD = [0.229, 0.224, 0.225];
    
    // 调试模式（使用全局变量以便动态切换）
    window.DEBUG_MODE = true;
    
    // 便捷访问函数
    function isDebugMode() {
      return window.DEBUG_MODE === true;
    }

    // 从 model.json 中尝试解析类别名称（多种常见字段）
    async function tryLoadLabelsFromModelJson(modelJsonData) {
      try {
        const j = modelJsonData;
        const candidates = [
          j?.userDefinedMetadata?.outputLabels,
          j?.userDefinedMetadata?.labels,
          j?.userDefinedMetadata?.classes,
          j?.metadata?.labels,
          j?.class_names,
          j?.modelTopology?.training_config?.class_names,
          j?.signature?.labels
        ];
        for (const c of candidates) {
          if (Array.isArray(c) && c.length && typeof c[0] === 'string') {
            labels = c;
            return true;
          }
        }
        // 有些导出会把 labels 放在 userDefinedMetadata 下的任意键
        const udm = j?.userDefinedMetadata;
        if (udm && typeof udm === 'object') {
          for (const k of Object.keys(udm)) {
            const v = udm[k];
            if (Array.isArray(v) && v.length && typeof v[0] === 'string') {
              labels = v;
              return true;
            }
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }

    async function tryLoadLabels(modelJsonData) {
      // 优先从 model.json 解析
      const ok = await tryLoadLabelsFromModelJson(modelJsonData);
      if (ok) return;
      // 可以在zip中包含labels.json文件作为备选
      if (modelFiles && modelFiles['labels.json']) {
        try {
          const labelsText = await modelFiles['labels.json'].async('text');
          labels = JSON.parse(labelsText);
        } catch (e) {
          // 无 labels.json 时忽略
        }
      }
    }

    async function loadModel() {
      if (!modelFiles) {
        STATUS.innerHTML = '<span style="color: #f59e0b;">⚠️ 请先上传模型文件</span>';
        return;
      }

      try {
        STATUS.innerHTML = '<span class="loading"></span> 正在加载模型…';
        
        // 从上传的文件创建 IOHandler
        const modelJsonText = await modelFiles['model.json'].async('text');
        const modelJsonData = JSON.parse(modelJsonText);
        const weightsBlob = await modelFiles['model.weights.bin'].async('blob');
        const weightData = await weightsBlob.arrayBuffer();
        
        // 提取 weight specs
        let weightSpecs = [];
        if (modelJsonData.weightsManifest && modelJsonData.weightsManifest.length > 0) {
          weightSpecs = modelJsonData.weightsManifest[0].weights || [];
        }
        
        // 创建自定义 IOHandler
        const customIOHandler = {
          load: async () => {
            return {
              modelTopology: modelJsonData.modelTopology,
              format: modelJsonData.format,
              generatedBy: modelJsonData.generatedBy,
              convertedBy: modelJsonData.convertedBy,
              weightSpecs: weightSpecs,
              weightData: weightData,
              userDefinedMetadata: modelJsonData.userDefinedMetadata
            };
          }
        };
        
        // 尝试作为 LayersModel 加载
        try {
          model = await tf.loadLayersModel(customIOHandler);
          modelType = 'layers';
          STATUS.innerHTML = '<span style="color: #48bb78;">✅ 模型加载成功（LayersModel）</span>';
          
          // 自动读取输入尺寸
          const shape = model.inputs?.[0]?.shape || null;
          if (shape && shape.length >= 3) {
            // 形如 [null, H, W, C]
            const h = shape[1] || inputSize;
            const w = shape[2] || inputSize;
            // 若不一致取较小者以保持方形
            inputSize = Math.min(h || inputSize, w || inputSize) || inputSize;
            STATUS.innerHTML += `<br><span class="small">输入尺寸：${inputSize}x${inputSize}</span>`;
          }
          
          // 输出模型信息用于调试
          if (isDebugMode()) {
            console.log('模型类型:', modelType);
            console.log('输入形状:', shape);
            console.log('输出形状:', model.outputs?.[0]?.shape);
            console.log('模型摘要:');
            model.summary();
          }
        } catch (err) {
          console.warn('尝试以 tfjs-layers 加载失败，改用 GraphModel…', err);
          model = await tf.loadGraphModel(customIOHandler);
          modelType = 'graph';
          STATUS.innerHTML = '<span style="color: #48bb78;">✅ 模型加载成功（GraphModel）</span>';
          // GraphModel 无法直接从 inputs.shape 读取，沿用默认 224
          STATUS.innerHTML += `<br><span class="small">输入尺寸：${inputSize}x${inputSize}</span>`;
        }
        
        await tryLoadLabels(modelJsonData);
        if (labels) {
          STATUS.innerHTML += `<br><span class="small">识别类别：${labels.length} 种植物</span>`;
          if (isDebugMode()) {
            console.log('标签列表:', labels);
          }
        }
        
        MODEL_PATH_EL.textContent = '用户上传的模型';
        PREDICT_BTN.disabled = false;
        
      } catch (err) {
        console.error('模型加载失败:', err);
        STATUS.innerHTML = '<span style="color: #e53e3e;">❌ 模型加载失败：' + err.message + '</span>';
        MODEL_PATH_EL.textContent = '加载失败';
      }
    }

    function showResults(probArray, topK = 5) {
      const indexed = probArray.map((p, i) => ({ i, p }));
      indexed.sort((a, b) => b.p - a.p);
      const tops = indexed.slice(0, topK);

      RESULTS.innerHTML = '';
      
      if (tops.length === 0) {
        RESULTS.innerHTML = '<div class="small">未识别到有效结果</div>';
        return;
      }

      tops.forEach(({ i, p }, index) => {
        const name = labels && labels[i] ? labels[i] : `植物类别 #${i + 1}`;
        const percentage = (p * 100).toFixed(2);
        const confidence = p > 0.8 ? '高' : p > 0.5 ? '中' : '低';
        
        const div = document.createElement('div');
        div.className = 'result-item';
        div.innerHTML = `
          <div>
            <strong>${index === 0 ? '🏆 ' : ''}${name}</strong>
            <div class="small">置信度：${confidence}</div>
          </div>
          <div class="result-percentage">${percentage}%</div>
        `;
        RESULTS.appendChild(div);
      });
    }

    // 预处理模式配置
    let preprocessMode = 'mobilenet_v2'; // 默认使用 MobileNetV2 标准预处理
    
    function preprocess(imgEl) {
      return tf.tidy(() => {
        let t = tf.browser.fromPixels(imgEl);
        
        if (isDebugMode()) {
          console.log('=== 图像预处理开始 ===');
          console.log('原始图像形状:', t.shape);
          console.log('原始图像值范围:', [tf.min(t).dataSync()[0], tf.max(t).dataSync()[0]]);
        }
        
        // 统一方形尺寸
        t = tf.image.resizeBilinear(t, [inputSize, inputSize], true);
        
        // 转为浮点数
        t = t.toFloat();
        
        // 根据模式选择预处理方式
        if (preprocessMode === 'simple') {
          // 模式1: 简单归一化到 [0,1]
          t = t.div(255);
          if (isDebugMode()) {
            console.log('预处理模式: 简单归一化 [0,1]');
          }
        } else if (preprocessMode === 'imagenet') {
          // 模式2: ImageNet 标准预处理
          // 归一化到 [0,1] 然后标准化
          t = t.div(255);
          const mean = tf.tensor1d(IMAGENET_MEAN);
          const std = tf.tensor1d(IMAGENET_STD);
          t = t.sub(mean).div(std);
          if (isDebugMode()) {
            console.log('预处理模式: ImageNet标准化 (mean=[0.485,0.456,0.406], std=[0.229,0.224,0.225])');
          }
        } else if (preprocessMode === 'mobilenet_v2') {
          // 模式3: MobileNetV2 / TensorFlow 标准预处理
          // 归一化到 [-1, 1]
          t = t.div(127.5).sub(1.0);
          if (isDebugMode()) {
            console.log('预处理模式: MobileNetV2标准化 [(x/127.5)-1] → [-1,1]');
          }
        } else if (preprocessMode === 'range_neg1_1') {
          // 模式4: 另一种归一化到 [-1,1] 的方式
          t = t.sub(127.5).div(127.5);
          if (isDebugMode()) {
            console.log('预处理模式: 归一化到 [-1,1] [(x-127.5)/127.5]');
          }
        } else if (preprocessMode === 'none') {
          // 模式5: 不做归一化，保持 [0,255]
          if (isDebugMode()) {
            console.log('预处理模式: 无标准化 [0,255]');
          }
        } else if (preprocessMode === 'caffe') {
          // 模式6: Caffe 风格 - BGR 顺序 + 减均值
          // 转换 RGB -> BGR
          const [r, g, b] = tf.split(t, 3, 2);
          t = tf.concat([b, g, r], 2);
          // 减去 ImageNet 均值 (BGR 顺序)
          const mean = tf.tensor1d([103.939, 116.779, 123.68]);
          t = t.sub(mean);
          if (isDebugMode()) {
            console.log('预处理模式: Caffe风格 (BGR + 减均值)');
          }
        }
        
        if (isDebugMode()) {
          console.log('预处理后形状:', t.shape);
          const minVal = tf.min(t).dataSync()[0];
          const maxVal = tf.max(t).dataSync()[0];
          const meanVal = tf.mean(t).dataSync()[0];
          console.log('预处理后统计: min=' + minVal.toFixed(4) + ', max=' + maxVal.toFixed(4) + ', mean=' + meanVal.toFixed(4));
          console.log('=== 图像预处理完成 ===');
        }
        
        // 增维： [1, H, W, C]
        t = t.expandDims(0);
        
        return t;
      });
    }

    async function predict() {
      if (!model || !PREVIEW.src) return;
      
      // 保存按钮原始状态
      const originalText = PREDICT_BTN.innerHTML;
      PREDICT_BTN.disabled = true;
      PREDICT_BTN.innerHTML = '⏳ 识别中...';
      
      RESULTS.innerHTML = '<div class="small" style="text-align: center; padding: 20px;">🔍 正在分析植物特征...</div>';
      
      try {
        if (isDebugMode()) {
          console.log('=== 开始预测 ===');
          console.log('模型类型:', modelType);
        }
        
        const input = preprocess(PREVIEW);
        
        if (isDebugMode()) {
          console.log('输入张量形状:', input.shape);
          console.log('输入张量值范围:', [tf.min(input).dataSync()[0], tf.max(input).dataSync()[0]]);
        }
        
        let output = null;
        
        // 根据模型类型使用不同的预测方法
        if (modelType === 'layers') {
          output = model.predict(input);
        } else if (modelType === 'graph') {
          output = model.execute(input);
        } else {
          // 兼容模式
          try {
            output = model.predict ? model.predict(input) : model.execute(input);
          } catch (e) {
            try {
              output = model.execute(input);
            } catch (e2) {
              throw new Error('无法执行模型预测');
            }
          }
        }

        // 兼容数组输出
        const outTensor = Array.isArray(output) ? output[0] : output;
        
        if (isDebugMode()) {
          console.log('输出张量形状:', outTensor.shape);
          console.log('输出张量值范围:', [tf.min(outTensor).dataSync()[0], tf.max(outTensor).dataSync()[0]]);
        }
        
        const probs = await outTensor.data();
        const probsArray = Array.from(probs);
        
        if (isDebugMode()) {
          console.log('预测概率:', probsArray);
          console.log('概率总和:', probsArray.reduce((a, b) => a + b, 0));
          probsArray.forEach((p, i) => {
            const label = labels && labels[i] ? labels[i] : `类别 ${i}`;
            console.log(`  ${label}: ${(p * 100).toFixed(2)}%`);
          });
          console.log('=== 预测完成 ===');
        }
        
        showResults(probsArray);
        tf.dispose([input, output]);
        
      } catch (e) {
        console.error('预测错误:', e);
        RESULTS.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #e53e3e;">
            <div>❌ 识别失败</div>
            <div class="small">${e.message || '未知错误'}</div>
          </div>
        `;
      } finally {
        // 恢复按钮状态
        PREDICT_BTN.disabled = false;
        PREDICT_BTN.innerHTML = originalText;
      }
    }

    function handleFileSelect(file) {
      if (!file || !file.type.startsWith('image/')) {
        alert('请选择有效的图片文件（JPG、PNG等格式）');
        return;
      }
      
      if (file.size > 10 * 1024 * 1024) {
        alert('图片文件大小不能超过10MB');
        return;
      }
      
      const url = URL.createObjectURL(file);
      PREVIEW.onload = () => {
        URL.revokeObjectURL(url);
        RESULTS.innerHTML = '';
        PLACEHOLDER_TEXT.style.display = 'none';
        PREVIEW.style.display = 'block';
      };
      PREVIEW.src = url;
    }

    // 处理模型文件上传
    MODEL_INPUT.addEventListener('change', async () => {
      const file = MODEL_INPUT.files?.[0];
      if (!file) return;
      
      if (!file.name.endsWith('.zip')) {
        alert('⚠️ 请选择 ZIP 格式的模型压缩包');
        return;
      }
      
      try {
        STATUS.innerHTML = '<span class="loading"></span> 正在解压模型文件…';
        MODEL_PATH_EL.textContent = '解压中...';
        
        const zip = await JSZip.loadAsync(file);
        
        // 查找 model.json 和 model.weights.bin
        let modelJson = null;
        let weightsFile = null;
        
        // 遍历zip文件，寻找model.json和weights文件
        for (const [filename, fileObj] of Object.entries(zip.files)) {
          if (fileObj.dir) continue;
          
          const baseName = filename.split('/').pop();
          if (baseName === 'model.json') {
            modelJson = fileObj;
          } else if (baseName === 'model.weights.bin' || baseName.endsWith('.weights.bin')) {
            weightsFile = fileObj;
          }
        }
        
        if (!modelJson || !weightsFile) {
          throw new Error('压缩包中缺少必需文件（model.json 或 model.weights.bin）');
        }
        
        modelFiles = {
          'model.json': modelJson,
          'model.weights.bin': weightsFile
        };
        
        // 检查是否有labels.json
        for (const [filename, fileObj] of Object.entries(zip.files)) {
          if (fileObj.dir) continue;
          const baseName = filename.split('/').pop();
          if (baseName === 'labels.json') {
            modelFiles['labels.json'] = fileObj;
            break;
          }
        }
        
        console.log('✅ 模型文件解压成功');
        console.log('- model.json:', modelJson.name);
        console.log('- weights:', weightsFile.name);
        if (modelFiles['labels.json']) {
          console.log('- labels.json:', modelFiles['labels.json'].name);
        }
        
        // 自动加载模型
        await loadModel();
        
      } catch (err) {
        console.error('模型上传失败:', err);
        STATUS.innerHTML = '<span style="color: #e53e3e;">❌ ' + err.message + '</span>';
        MODEL_PATH_EL.textContent = '加载失败';
        alert('❌ 模型上传失败：' + err.message);
      }
    });

    FILE_INPUT.addEventListener('change', () => {
      const file = FILE_INPUT.files?.[0];
      handleFileSelect(file);
    });

    // 拖放功能
    IMG_WRAP.addEventListener('dragover', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.add('drag-over');
    });

    IMG_WRAP.addEventListener('dragleave', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
    });

    IMG_WRAP.addEventListener('drop', (e) => {
      e.preventDefault();
      IMG_WRAP.classList.remove('drag-over');
      const file = e.dataTransfer.files[0];
      handleFileSelect(file);
    });

    // 点击预览区域也可以选择文件
    IMG_WRAP.addEventListener('click', () => {
      FILE_INPUT.click();
    });

    PREDICT_BTN.addEventListener('click', predict);

    // 自动测试所有模式
    const TEST_ALL_BTN = document.getElementById('testAllBtn');
    TEST_ALL_BTN.addEventListener('click', async () => {
      if (!model || !PREVIEW.src) {
        alert('⚠️ 请先上传图片！');
        return;
      }
      
      const modes = ['mobilenet_v2', 'range_neg1_1', 'simple', 'imagenet', 'caffe', 'none'];
      const modeNames = {
        'mobilenet_v2': '模式3: MobileNetV2 [-1,1]',
        'range_neg1_1': '模式4: 另一种 [-1,1]',
        'simple': '模式1: 简单 [0,1]',
        'imagenet': '模式2: ImageNet标准化',
        'caffe': '模式6: Caffe风格',
        'none': '模式5: 无标准化 [0,255]'
      };
      
      TEST_ALL_BTN.disabled = true;
      TEST_ALL_BTN.innerHTML = '⏳ 测试中...';
      
      console.log('\n' + '='.repeat(70));
      console.log('🧪 开始自动测试所有预处理模式');
      console.log('='.repeat(70));
      console.log('📸 当前图片已加载，将依次测试 6 种预处理模式\n');
      
      const results = [];
      
      for (let i = 0; i < modes.length; i++) {
        const mode = modes[i];
        preprocessMode = mode;
        PREPROCESS_SELECT.value = mode;
        
        console.log(`\n[${ i + 1}/6] 测试 ${modeNames[mode]}`);
        console.log('-'.repeat(70));
        
        try {
          const input = preprocess(PREVIEW);
          let output = null;
          
          if (modelType === 'layers') {
            output = model.predict(input);
          } else if (modelType === 'graph') {
            output = model.execute(input);
          } else {
            output = model.predict ? model.predict(input) : model.execute(input);
          }
          
          const outTensor = Array.isArray(output) ? output[0] : output;
          const probs = await outTensor.data();
          const probsArray = Array.from(probs);
          
          // 找出最高概率的类别
          let maxProb = -1;
          let maxIdx = -1;
          probsArray.forEach((p, idx) => {
            if (p > maxProb) {
              maxProb = p;
              maxIdx = idx;
            }
          });
          
          const predictedLabel = labels && labels[maxIdx] ? labels[maxIdx] : `类别 ${maxIdx}`;
          
          results.push({
            mode: modeNames[mode],
            label: predictedLabel,
            confidence: maxProb,
            probs: probsArray
          });
          
          console.log(`✅ 预测结果: ${predictedLabel} (${(maxProb * 100).toFixed(2)}%)`);
          console.log('完整概率分布:');
          probsArray.forEach((p, idx) => {
            const label = labels && labels[idx] ? labels[idx] : `类别 ${idx}`;
            console.log(`  ${label}: ${(p * 100).toFixed(2)}%`);
          });
          
          tf.dispose([input, output]);
          
          // 短暂延迟以便查看
          await new Promise(resolve => setTimeout(resolve, 100));
          
        } catch (e) {
          console.error(`❌ ${modeNames[mode]} 测试失败:`, e.message);
          results.push({
            mode: modeNames[mode],
            label: '错误',
            confidence: 0,
            error: e.message
          });
        }
      }
      
      // 输出汇总
      console.log('\n' + '='.repeat(70));
      console.log('📊 测试结果汇总');
      console.log('='.repeat(70));
      
      const summary = {};
      results.forEach(r => {
        if (!r.error) {
          if (!summary[r.label]) {
            summary[r.label] = [];
          }
          summary[r.label].push({mode: r.mode, conf: r.confidence});
        }
      });
      
      console.log('\n按预测类别分组:');
      Object.keys(summary).forEach(label => {
        console.log(`\n🏷️  ${label}:`);
        summary[label].forEach(item => {
          console.log(`   ${item.mode}: ${(item.conf * 100).toFixed(2)}%`);
        });
      });
      
      console.log('\n' + '='.repeat(70));
      console.log('💡 使用建议:');
      console.log('   1. 查看哪个模式预测出了正确的类别（小草）');
      console.log('   2. 选择该模式作为默认预处理方式');
      console.log('   3. 用多张训练图片验证该模式的准确性');
      console.log('='.repeat(70) + '\n');
      
      TEST_ALL_BTN.disabled = false;
      TEST_ALL_BTN.innerHTML = '🧪 自动测试所有模式';
      
      alert('✅ 测试完成！请查看控制台查看详细结果。');
    });

    // 预处理模式切换
    const PREPROCESS_SELECT = document.getElementById('preprocessSelect');
    PREPROCESS_SELECT.addEventListener('change', (e) => {
      preprocessMode = e.target.value;
      console.log('\n' + '='.repeat(50));
      console.log('🔄 预处理模式已切换为:', preprocessMode);
      
      const modeDescriptions = {
        'simple': '简单归一化 x/255 → [0,1]',
        'imagenet': 'ImageNet标准化 (x/255 - mean)/std',
        'mobilenet_v2': 'MobileNetV2标准化 x/127.5 - 1 → [-1,1] ⭐推荐',
        'range_neg1_1': '另一种[-1,1]方式 (x-127.5)/127.5',
        'none': '无标准化，保持 [0,255]',
        'caffe': 'Caffe风格 BGR + 减均值'
      };
      
      console.log('📝 说明:', modeDescriptions[preprocessMode] || '未知模式');
      console.log('💡 提示: 上传图片后点击"开始识别"测试此模式');
      console.log('='.repeat(50) + '\n');
      
      // 如果已经有图片，提示可以重新预测
      if (PREVIEW.src && model) {
        console.log('ℹ️  检测到已上传图片，可以直接点击"开始识别"按钮测试新模式');
      }
    });

    // 调试开关
    const DEBUG_TOGGLE = document.getElementById('debugToggle');
    DEBUG_TOGGLE.addEventListener('change', (e) => {
      window.DEBUG_MODE = e.target.checked;
      console.log('调试模式:', window.DEBUG_MODE ? '开启' : '关闭');
    });
    
    // 初始化预处理模式
    preprocessMode = 'mobilenet_v2'; // 设置默认值为 MobileNetV2
    PREPROCESS_SELECT.value = 'mobilenet_v2'; // 同步下拉框
    
    console.log('\n' + '='.repeat(60));
    console.log('🌿 植物识别系统已启动');
    console.log('='.repeat(60));
    console.log('📌 默认预处理模式: MobileNetV2标准化 [-1,1]');
    console.log('📌 这是TensorFlow预训练MobileNet模型的标准预处理方式');
    console.log('');
    console.log('📦 使用步骤:');
    console.log('  1️⃣  上传模型压缩包（包含 model.json 和 model.weights.bin）');
    console.log('  2️⃣  等待模型加载完成');
    console.log('  3️⃣  上传植物图片进行识别');
    console.log('');
    console.log('🔧 如果训练集图片预测错误，请尝试以下步骤:');
    console.log('  1️⃣  上传小草的训练图片');
    console.log('  2️⃣  查看控制台的预测结果');
    console.log('  3️⃣  如果错误，切换预处理模式并重新识别');
    console.log('  4️⃣  测试所有6种模式，找出正确结果的模式');
    console.log('');
    console.log('💡 建议测试顺序:');
    console.log('   模式3 (MobileNetV2) → 模式4 ([-1,1]) → 模式1 ([0,1])');
    console.log('   → 模式2 (ImageNet) → 模式6 (Caffe) → 模式5 ([0,255])');
    console.log('='.repeat(60) + '\n');

    // 初始化状态
    STATUS.innerHTML = '<span style="color: #f59e0b;">⚠️ 请上传模型文件</span>';
    MODEL_PATH_EL.textContent = '未上传';
  </script>
</body>
</html>